package repository

import (
	"context"
	"log"

	"github.com/xlund/tracker/internal/domain"
)

type postgresUserRepository struct {
	conn Connection
}

func NewPostgresUser(conn Connection) domain.UserRepository {
	return &postgresUserRepository{conn: conn}
}

func (r *postgresUserRepository) fetch(ctx context.Context, query string, args ...interface{}) ([]domain.User, error) {
	rows, err := r.conn.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var uu []domain.User
	for rows.Next() {
		var u domain.User
		if err := rows.Scan(&u.ID, &u.Username, &u.Name); err != nil {
			return nil, err
		}
		uu = append(uu, u)
	}
	return uu, nil
}

func (r *postgresUserRepository) GetById(ctx context.Context, id string) (domain.User, error) {
	query := `
		SELECT u.id, u.username, u.name, g.id, g.white, g.black, wp.username, bp.username
		FROM users u
		LEFT JOIN game g ON u.id = g.white OR u.id = g.black
		WHERE id = $1`

	uu, err := r.fetch(ctx, query, id)
	if err != nil {
		return domain.User{}, err
	}
	if len(uu) == 0 {
		return domain.User{}, domain.ErrNotFound
	}

	log.Default().Println(uu[0])

	return uu[0], nil

}

func (r *postgresUserRepository) GetByIdWithGames(ctx context.Context, id string) (domain.UserWithGames, error) {
	log.Default().Println("GetByIdWithGames")
	query := `
	SELECT
    u.id AS user_id,
    u.username AS user_username,
    u.name AS user_name,
    g.id AS game_id,
    g.white AS white_player_id,
    gwu.username AS white_player_username,
    g.black AS black_player_id,
    gbu.username AS black_player_username
FROM
    users u
LEFT JOIN
    games g ON u.id = g.white OR u.id = g.black
LEFT JOIN
    users gwu ON g.white = gwu.id
LEFT JOIN
    users gbu ON g.black = gbu.id
WHERE
    u.id = $1;
		`

	rows, err := r.conn.Query(ctx, query, id)
	if err != nil {
		return domain.UserWithGames{}, err
	}
	defer rows.Close()

	var uu domain.UserWithGames
	log.Default().Println("GetByIdWithGames:Query Complete")
	for rows.Next() {
		var u domain.User
		var g domain.Game

		log.Default().Println("GetByIdWithGames:Scan")

		if err := rows.Scan(&u.ID, &u.Username, &u.Name, &g.ID, &g.Users.White.ID, &g.Users.White.Username, &g.Users.Black.ID, &g.Users.Black.Username); err != nil {
			return domain.UserWithGames{}, err
		}
		uu.User = u
		uu.Games = append(uu.Games, g)
	}
	log.Default().Println(uu.Games)

	return uu, nil

}

func (r *postgresUserRepository) Search(ctx context.Context, q string) ([]domain.User, error) {
	query := `
		SELECT id, username, name
		FROM users
		WHERE username ILIKE $1`
	return r.fetch(ctx, query, "%"+q+"%")
}

func (r *postgresUserRepository) GetAll(ctx context.Context) ([]domain.User, error) {
	query := `
		SELECT id, username, name
		FROM users`
	return r.fetch(ctx, query)
}

func (r *postgresUserRepository) GetByUsername(ctx context.Context, username string) (domain.User, error) {
	query := `
		SELECT id, username, name
		FROM users
		WHERE username = $1`

	uu, err := r.fetch(ctx, query, username)
	if err != nil {
		return domain.User{}, err
	}
	if len(uu) == 0 {
		return domain.User{}, domain.ErrNotFound
	}

	return uu[0], nil
}

func (r *postgresUserRepository) CreateOrUpdate(ctx context.Context, u *domain.User) error {
	if err := u.Validate(); err != nil {
		return err
	}
	// Id is generated by the database
	query := `
		INSERT INTO users (id, username, name)
		VALUES ($1, $2, $3)
		ON CONFLICT (username) DO NOTHING
		RETURNING id`
	return r.conn.QueryRow(ctx, query, u.ID, u.Username, u.Name).Scan(&u.ID)
}

func (r *postgresUserRepository) Delete(ctx context.Context, id string) error {
	query := `DELETE FROM users WHERE id = $1`
	_, err := r.conn.Exec(ctx, query, id)
	return err
}
