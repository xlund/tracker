package repository

import (
	"context"
	"log"

	"github.com/xlund/tracker/internal/domain"
)

type postgresUserRepository struct {
	conn Connection
}

func NewPostgresUser(conn Connection) domain.UserRepository {
	return &postgresUserRepository{conn: conn}
}

func (r *postgresUserRepository) fetch(ctx context.Context, query string, args ...interface{}) ([]domain.User, error) {
	rows, err := r.conn.Query(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var uu []domain.User
	for rows.Next() {
		var u domain.User
		if err := rows.Scan(&u.ID, &u.Username, &u.Name); err != nil {
			return nil, err
		}
		uu = append(uu, u)
	}
	return uu, nil
}

func (r *postgresUserRepository) GetById(ctx context.Context, id string) (domain.User, error) {
	query := `
		SELECT u.id, u.username, u.name, g.id, g.white, g.black, wp.username, bp.username
		FROM users u
		LEFT JOIN game_Users g ON u.id = g.white OR u.id = g.black
		LEFT JOIN users wp ON g.white = wp.id
		LEFT JOIN users bp ON g.black = bp.id
		WHERE id = $1`

	uu, err := r.fetch(ctx, query, id)
	if err != nil {
		return domain.User{}, err
	}
	if len(uu) == 0 {
		return domain.User{}, domain.ErrNotFound
	}

	log.Default().Println(uu[0])

	return uu[0], nil

}

func (r *postgresUserRepository) GetByIdWithGames(ctx context.Context, id string) (domain.User, []domain.Game, error) {
	query := `
	SELECT
    u.id AS user_id,
    u.username AS user_username,
    u.name AS user_name,
    COALESCE(g.id, 0) AS game_id,
	COALESCE(g.white, 'removed') AS game_white_user_id,
	COALESCE(g.black, 'removed') AS game_black_user_id,
	COALESCE(wp.username, 'removed') AS white_player_username,
	COALESCE(bp.username, 'removed') AS black_player_username
FROM
    users u
LEFT JOIN
    game_users g ON u.id = g.white OR u.id = g.black
LEFT JOIN
    users wp ON g.white = wp.id
LEFT JOIN
    users bp ON g.black = bp.id
WHERE
    u.id = $1;`

	rows, err := r.conn.Query(ctx, query, id)
	if err != nil {
		return domain.User{}, []domain.Game{}, err
	}
	defer rows.Close()

	var uu []domain.User
	var gg []domain.Game
	for rows.Next() {
		var u domain.User
		var g domain.Game
		if err := rows.Scan(&u.ID, &u.Username, &u.Name, &g.ID, &g.Users.White.ID, &g.Users.Black.ID, &g.Users.White.Username, &g.Users.Black.Username); err != nil {
			return domain.User{}, []domain.Game{}, err
		}
		uu = append(uu, u)
		gg = append(gg, g)
	}
	if len(uu) == 0 {
		return domain.User{}, []domain.Game{}, domain.ErrNotFound
	}

	return uu[0], gg, nil

}

func (r *postgresUserRepository) GetAll(ctx context.Context) ([]domain.User, error) {
	query := `
		SELECT id, username, name
		FROM users`
	return r.fetch(ctx, query)
}

func (r *postgresUserRepository) GetByUsername(ctx context.Context, username string) (domain.User, error) {
	query := `
		SELECT id, username, name
		FROM users
		WHERE username = $1`

	uu, err := r.fetch(ctx, query, username)
	if err != nil {
		return domain.User{}, err
	}
	if len(uu) == 0 {
		return domain.User{}, domain.ErrNotFound
	}

	return uu[0], nil
}

func (r *postgresUserRepository) CreateOrUpdate(ctx context.Context, u *domain.User) error {
	if err := u.Validate(); err != nil {
		return err
	}
	// Id is generated by the database
	query := `
		INSERT INTO users (id, username, name)
		VALUES ($1, $2, $3)
		ON CONFLICT (username) DO NOTHING
		RETURNING id`
	return r.conn.QueryRow(ctx, query, u.ID, u.Username, u.Name).Scan(&u.ID)
}

func (r *postgresUserRepository) Delete(ctx context.Context, id string) error {
	query := `DELETE FROM users WHERE id = $1`
	_, err := r.conn.Exec(ctx, query, id)
	return err
}
